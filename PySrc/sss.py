# sss.py
# Author: Jun Kurihara <kurihara at ieee.org>

from PySrc.gf2m import GF2m
import numpy as np
from typing import List
import secrets

class SSS:
    # constructor
    def __init__(self):
        self._secret = None
        self._shares = None
        self._share_index_list = None
        self._threshold = 0
        self._ramp = 0
        self._num = 0
        self.random = None
        self.gf = GF2m()
        self.coefficient_matrix = None
        self.orig_secret_size = 0

    # private functions
    def __set_params(self, threshold: int, ramp: int, num: int) -> None:
        # print("{0}: Set params: (k,l,n) = ({1}, {2}, {3})".format(self, threshold, ramp, num))
        self._threshold = threshold
        self._ramp = ramp
        self._num = num

    def __set_coefficient_matrix(self) -> None:
        # todo: Reconsider how to set indices
        # this method is implemented under an assumption that indices are enumerated
        # not as multiplicative elements in GF(2^m) [1, a^1, ..., a^{n-1}] but just as integers [1, 2, ..., n]
        self.coefficient_matrix = np.ones(self._num, np.int)
        self.coefficient_matrix = np.vstack((self.coefficient_matrix, np.arange(1, self._num + 1, 1)))
        for i in range(self._threshold - 2):
            self.coefficient_matrix = np.vstack((self.coefficient_matrix,
                                                 self.gf.vmul_gf2m(
                                                     self.coefficient_matrix[1],
                                                     self.coefficient_matrix[i + 1])))

        self.coefficient_matrix = self.coefficient_matrix.transpose()
        # print("{0}: coefficient (Vandermonde) matrix = \n{1}".format(self, self.coefficient_matrix))

    def __generate_random(self) -> None:
        # Now random numbers are generated by os.urandom in secrets.SystemRandom that is probably cryptographically secure.
        rng = secrets.SystemRandom()
        self.random = np.empty([self._threshold - self._ramp, int(self._secret.size / self._ramp)])
        self.random = np.vectorize(lambda a: rng.randint(0, self.gf.mord))(self.random)
        #print("Random = {0}".format(self.random))

        #self.random = np.random.randint(0, self.gf.mord,
        #                                [self._threshold - self._ramp, int(self._secret.size / self._ramp)])
        # print("{0}: Set random values = {1}".format(self, self._random))

    # public functions
    def initialize(self, deg: int, threshold: int, ramp: int, num: int) -> None:
        self.__init__()
        self.gf.set_degree(deg)
        self.__set_params(threshold, ramp, num)
        self.__set_coefficient_matrix()

    def generate_shares(self) -> None:
        self.__generate_random()
        # todo: reconsider this algorithm of waste of memory
        concat = np.vstack((self._secret, self.random)).transpose()
        self._shares = []
        self._share_index_list = []
        # todo: define individual method in gf2m.py
        for i in range(self._num):
            tmp = self.gf.vmul_gf2m(concat, self.coefficient_matrix[i]).transpose()
            self._shares.append(tmp[0])
            for j in range(self._threshold - 1):
                self._shares[i] = self.gf.vadd_gf2m(self._shares[i], tmp[j + 1])
            self._share_index_list.append(i)
            # print("{0}: share {1} = {2}".format(self, i, self._shares[i]))

    def set_secret(self, secret: np.ndarray) -> None:
        self.orig_secret_size = secret.size
        if secret.size % self._ramp != 0:
            app = np.array([0] * (self._ramp - (secret.size % self._ramp)))
            secret = np.append(secret, app)
        self._secret = np.resize(secret, [self._ramp, int(secret.size / self._ramp)])
        # print("{0}: Set a secret = {1}".format(self, self._secret))

    def set_external_shares(self, shares: List, index_list: List) -> None:
        self._shares = shares
        self._share_index_list = index_list[:self._threshold]

    # todo
    def reconstruct_secret(self, orig_size: int) -> None:
        self.orig_secret_size = orig_size;
        submatrix = self.coefficient_matrix[self._share_index_list[0]]
        for i in self._share_index_list[1:]:
             submatrix = np.vstack((submatrix, self.coefficient_matrix[i]))
        #print("submatrix = \n{0}".format(submatrix.transpose()))
        submatrix = self.gf.inverse_matrix_gf2m(submatrix.transpose()).transpose()
        # print("inverse = \n{0}".format(submatrix))
        self._shares = np.array(self._shares).transpose()
        #print("transposed shares = \n{0}".format(self._shares))

        sec = np.zeros((self._ramp, self._shares.shape[0]), dtype=np.int)
        for i in range(self._ramp):
            tmp = self.gf.vmul_gf2m(submatrix[i], self._shares).transpose()
            for j in range(self._threshold):
                sec[i] = self.gf.vadd_gf2m(sec[i], tmp[j])

        # reshape the secret matrix and set as an instance variable
        self._secret = np.reshape(sec, (1, -1))[0][:self.orig_secret_size]


def test_sss():
    s = SSS()
    deg = 8
    threshold = 3
    ramp = 1
    num = 11
    org_size = 1024
    index_list = [0, 3, 7]
    shares = []

    np.set_printoptions(formatter={'int': hex})

    # share generation
    print("\nShare generation:")
    print("Params: (k, l, n, degree) = ({0}, {1}, {2}, {3})".format(threshold, ramp, num, deg))
    nvec = np.random.randint(0, (1 << deg) - 1, org_size)
    print("Secret: {0}".format(nvec))
    s.initialize(deg, threshold, ramp, num)
    s.set_secret(nvec)
    s.generate_shares()
    for i in range(num):
        print("Share {0}: {1}".format(s._share_index_list[i], s._shares[i]))

    for i in index_list:
        shares.append(s._shares[i])
    # secret reconstruct
    print("\nSecret reconstruction:")
    s.initialize(deg, threshold, ramp, num)
    s.set_external_shares(shares, index_list)
    print("Given params: (k, l, n, degree, share indices, original size) = ({0}, {1}, {2}, {3}, {4}, {5})"
          .format(threshold, ramp, num, deg, s._share_index_list, org_size))
    for i, j in zip(s._share_index_list, s._shares):
        print("Given share {0}: {1}".format(i, j))
    s.reconstruct_secret(org_size)
    print("Reconstructed secret: {0}".format(s._secret))



if __name__ == '__main__':
    test_sss()
