"""
    sss.py: A Python library for secret sharing scheme based on polynomial interpolation
    Author: Jun Kurihara <kurihara at ieee.org>
"""

import gf2m
import secrets
from typing import List

import numpy as np


class SSS:
    # constructor
    def __init__(self):
        self._secret = None
        self._shares = None
        self._share_index_list = None
        self._threshold = 0
        self._ramp = 0
        self._num = 0
        self.random = None
        self.gf = gf2m.GF2m()
        self.coefficient_matrix = None
        self.orig_secret_size = 0

    # private functions
    def __set_params(self, threshold: int, ramp: int, num: int) -> None:
        # print("{0}: Set params: (k,l,n) = ({1}, {2}, {3})".format(self, threshold, ramp, num))
        self._threshold = threshold
        self._ramp = ramp
        self._num = num

    def __set_coefficient_matrix(self) -> None:
        # todo: Reconsider how to set indices
        # this method is implemented under an assumption that indices are enumerated
        # not as multiplicative elements in GF(2^m) [1, a^1, ..., a^{n-1}] but just as integers [1, 2, ..., n]
        self.coefficient_matrix = np.ones(self._num, np.int)
        self.coefficient_matrix = np.vstack((self.coefficient_matrix, np.arange(1, self._num + 1, 1)))
        for i in range(self._threshold - 2):
            self.coefficient_matrix = np.vstack((self.coefficient_matrix,
                                                 self.gf.vmul_gf2m(
                                                     self.coefficient_matrix[1],
                                                     self.coefficient_matrix[i + 1])))

        self.coefficient_matrix = self.coefficient_matrix.transpose()
        # print("{0}: coefficient (Vandermonde) matrix = \n{1}".format(self, self.coefficient_matrix))

    def __generate_random(self) -> None:
        # Now random numbers are generated by os.urandom in secrets.SystemRandom
        # that is probably cryptographically secure.
        rng = secrets.SystemRandom()
        self.random = np.empty([self._threshold - self._ramp, int(self._secret.size / self._ramp)])
        self.random = np.vectorize(lambda a: rng.randint(0, self.gf.mord))(self.random)
        # print("Random = {0}".format(self.random))

        # self.random = np.random.randint(0, self.gf.mord,
        #                                [self._threshold - self._ramp, int(self._secret.size / self._ramp)])
        # print("{0}: Set random values = {1}".format(self, self._random))

    # public functions
    def initialize(self, deg: int, threshold: int, ramp: int, num: int) -> None:
        self.gf.set_degree(deg)
        self.__set_params(threshold, ramp, num)
        self.__set_coefficient_matrix()

    def generate_shares(self) -> None:
        self.__generate_random()
        # todo: reconsider this algorithm of waste of memory
        concat = np.vstack((self._secret, self.random)).transpose()
        self._shares = []
        self._share_index_list = []
        # todo: define individual method in gf2m.py
        for i in range(self._num):
            tmp = self.gf.vmul_gf2m(concat, self.coefficient_matrix[i]).transpose()
            self._shares.append(tmp[0])
            for j in range(self._threshold - 1):
                self._shares[i] = self.gf.vadd_gf2m(self._shares[i], tmp[j + 1])
            self._share_index_list.append(i)
            # print("{0}: share {1} = {2}".format(self, i, self._shares[i]))

    def set_secret(self, secret: np.ndarray) -> None:
        self.orig_secret_size = secret.size
        if secret.size % self._ramp != 0:
            app = np.array([0] * (self._ramp - (secret.size % self._ramp)))
            secret = np.append(secret, app)
        self._secret = np.resize(secret, [self._ramp, int(secret.size / self._ramp)])
        # print("{0}: Set a secret = {1}".format(self, self._secret))

    def set_external_shares(self, shares: List, index_list: List) -> None:
        self._shares = shares
        self._share_index_list = index_list[:self._threshold]

    def reconstruct_secret(self, orig_size: int) -> None:
        self.orig_secret_size = orig_size
        submatrix = self.coefficient_matrix[self._share_index_list[0]]
        for i in self._share_index_list[1:]:
            submatrix = np.vstack((submatrix, self.coefficient_matrix[i]))
        # print("submatrix = \n{0}".format(submatrix.transpose()))
        submatrix = self.gf.inverse_matrix_gf2m(submatrix.transpose()).transpose()
        # print("inverse = \n{0}".format(submatrix))
        self._shares = np.array(self._shares).transpose()

        sec = np.zeros((self._ramp, self._shares.shape[0]), dtype=np.int)
        for i in range(self._ramp):
            tmp = self.gf.vmul_gf2m(submatrix[i], self._shares).transpose()
            for j in range(self._threshold):
                sec[i] = self.gf.vadd_gf2m(sec[i], tmp[j])

        # reshape the secret matrix and set as an instance variable
        self._secret = np.reshape(sec, (1, -1))[0][:self.orig_secret_size]
